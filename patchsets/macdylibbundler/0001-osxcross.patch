From 295068a23b4af76f2a3268c10b420c78f9a5e1a5 Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Thu, 6 Dec 2018 17:30:55 -0700
Subject: [PATCH] osxcross

---
 CMakeLists.txt       | 34 ++++++++++++++++++++++++++++++++++
 src/Constants.h      | 20 ++++++++++++++++++++
 src/Dependency.cpp   | 40 ++++++++++++++++++++--------------------
 src/Dependency.h     | 10 ++++++----
 src/DylibBundler.cpp | 44 ++++++++++++++++++++++----------------------
 src/DylibBundler.h   |  2 ++
 6 files changed, 104 insertions(+), 46 deletions(-)
 create mode 100644 CMakeLists.txt
 create mode 100644 src/Constants.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..e9d02be
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,34 @@
+cmake_minimum_required(VERSION 3.2)
+project(macdylibbundler)
+set (QT_MIN_VERSION "5.5.0")
+
+# taken from osxcross toolchain file
+macro(osxcross_getconf VAR)
+  if(NOT ${VAR})
+    set(${VAR} "$ENV{${VAR}}")
+    if(${VAR})
+      set(${VAR} "${${VAR}}" CACHE STRING "${VAR}")
+      message(STATUS "Found ${VAR}: ${${VAR}}")
+    else()
+      message(WARNING "Cannot determine \"${VAR}\"")
+    endif()
+  endif()
+endmacro()
+
+osxcross_getconf(OSXCROSS_HOST)
+
+if(NOT "${CMAKE_SYSTEM_NAME}" STREQUAL "Darwin")
+  if(OSXCROSS_HOST)
+    add_definitions(-DOSXCROSS_HOST="${OSXCROSS_HOST}")
+  else()
+    message(FATAL_ERROR "This is intended to use with osxcross. If you have osxcross prepared, run eval `osxcross-conf`")
+  endif(OSXCROSS_HOST)
+endif()
+
+add_executable(macdylibbundler
+  ./src/Dependency.cpp
+  ./src/DylibBundler.cpp
+  ./src/Settings.cpp
+  ./src/Utils.cpp
+  ./src/main.cpp
+)
diff --git a/src/Constants.h b/src/Constants.h
new file mode 100644
index 0000000..f5c2d0d
--- /dev/null
+++ b/src/Constants.h
@@ -0,0 +1,20 @@
+#include <string>
+
+#ifndef DYLIBBUNDLER_CONST
+#define DYLIBBUNDLER_CONST
+
+const std::string install_name_tool =
+#ifndef OSXCROSS_HOST
+"install_name_tool";
+#else
+OSXCROSS_HOST "-install_name_tool";
+#endif
+
+const std::string otool =
+#ifndef OSXCROSS_HOST
+"otool";
+#else
+OSXCROSS_HOST "-otool";
+#endif
+
+#endif
diff --git a/src/Dependency.cpp b/src/Dependency.cpp
index 9e3c856..308dcad 100644
--- a/src/Dependency.cpp
+++ b/src/Dependency.cpp
@@ -118,14 +118,14 @@ Dependency::Dependency(std::string path)
         filename = stripPrefix(path);
         prefix = path.substr(0, path.rfind("/")+1);
     }
-    
+
     //check if the lib is in a known location
     if( !prefix.empty() && prefix[ prefix.size()-1 ] != '/' ) prefix += "/";
     if( prefix.empty() || !fileExists( prefix+filename ) )
     {
         //the paths contains at least /usr/lib so if it is empty we have not initialized it
         if( paths.empty() ) initSearchPaths();
-        
+
         //check if file is contained in one of the paths
         for( size_t i=0; i<paths.size(); ++i)
         {
@@ -138,17 +138,17 @@ Dependency::Dependency(std::string path)
             }
         }
     }
-    
+
     //If the location is still unknown, ask the user for search path
     if( !Settings::isPrefixIgnored(prefix)
         && ( prefix.empty() || !fileExists( prefix+filename ) ) )
     {
         std::cerr << "\n/!\\ WARNING : Library " << filename << " has an incomplete name (location unknown)" << std::endl;
         missing_prefixes = true;
-        
+
         paths.push_back(getUserInputDirForFile(filename));
     }
-    
+
     //new_name  = filename.substr(0, filename.find(".")) + ".dylib";
     new_name = filename;
 }
@@ -157,7 +157,7 @@ void Dependency::print()
 {
     std::cout << std::endl;
     std::cout << " * " << filename.c_str() << " from " << prefix.c_str() << std::endl;
-    
+
     const int symamount = symlinks.size();
     for(int n=0; n<symamount; n++)
         std::cout << "     symlink --> " << symlinks[n].c_str() << std::endl;;
@@ -197,9 +197,9 @@ bool Dependency::mergeIfSameAs(Dependency& dep2)
 void Dependency::copyYourself()
 {
     copyFile(getOriginalPath(), getInstallPath());
-    
+
     // Fix the lib's inner name
-    std::string command = std::string("install_name_tool -id ") + getInnerPath() + " " + getInstallPath();
+    std::string command = install_name_tool + std::string(" -id ") + getInnerPath() + " " + getInstallPath();
     if( systemp( command ) != 0 )
     {
         std::cerr << "\n\nError : An error occured while trying to change identity of library " << getInstallPath() << std::endl;
@@ -210,50 +210,50 @@ void Dependency::copyYourself()
 void Dependency::fixFileThatDependsOnMe(std::string file_to_fix)
 {
     // for main lib file
-    std::string command = std::string("install_name_tool -change ") +
+    std::string command = install_name_tool + std::string(" -change ") +
     getOriginalPath() + " " + getInnerPath() + " " + file_to_fix;
-    
+
     if( systemp( command ) != 0 )
     {
         std::cerr << "\n\nError : An error occured while trying to fix depencies of " << file_to_fix << std::endl;
         exit(1);
     }
-    
+
     // for symlinks
     const int symamount = symlinks.size();
     for(int n=0; n<symamount; n++)
     {
-        command = std::string("install_name_tool -change ") +
+        command = install_name_tool + std::string(" -change ") +
         symlinks[n] + " " + getInnerPath() + " " + file_to_fix;
-        
+
         if( systemp( command ) != 0 )
         {
             std::cerr << "\n\nError : An error occured while trying to fix depencies of " << file_to_fix << std::endl;
             exit(1);
         }
     }
-    
-    
+
+
     // FIXME - hackish
     if(missing_prefixes)
     {
         // for main lib file
-        command = std::string("install_name_tool -change ") +
+        command = install_name_tool + std::string(" -change ") +
         filename + " " + getInnerPath() + " " + file_to_fix;
-        
+
         if( systemp( command ) != 0 )
         {
             std::cerr << "\n\nError : An error occured while trying to fix depencies of " << file_to_fix << std::endl;
             exit(1);
         }
-        
+
         // for symlinks
         const int symamount = symlinks.size();
         for(int n=0; n<symamount; n++)
         {
-            command = std::string("install_name_tool -change ") +
+            command = install_name_tool + std::string(" -change ") +
             symlinks[n] + " " + getInnerPath() + " " + file_to_fix;
-            
+
             if( systemp( command ) != 0 )
             {
                 std::cerr << "\n\nError : An error occured while trying to fix depencies of " << file_to_fix << std::endl;
diff --git a/src/Dependency.h b/src/Dependency.h
index ca4f153..2c8b209 100644
--- a/src/Dependency.h
+++ b/src/Dependency.h
@@ -29,13 +29,15 @@ THE SOFTWARE.
 #include <string>
 #include <vector>
 
+#include "Constants.h"
+
 class Dependency
 {
     // origin
     std::string filename;
     std::string prefix;
     std::vector<std::string> symlinks;
-    
+
     // installation
     std::string new_name;
 public:
@@ -47,7 +49,7 @@ public:
     std::string getOriginalPath() const{ return prefix+filename; }
     std::string getInstallPath();
     std::string getInnerPath();
-        
+
     void addSymlink(std::string s);
     int getSymlinkAmount() const{ return symlinks.size(); }
 
@@ -56,11 +58,11 @@ public:
 
     void copyYourself();
     void fixFileThatDependsOnMe(std::string file);
-    
+
     // comapres the given Dependency with this one. If both refer to the same file,
     // it returns true and merges both entries into one.
     bool mergeIfSameAs(Dependency& dep2);
 };
 
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/DylibBundler.cpp b/src/DylibBundler.cpp
index 3a4ffd3..83d4646 100644
--- a/src/DylibBundler.cpp
+++ b/src/DylibBundler.cpp
@@ -43,7 +43,7 @@ std::map<std::string, std::vector<std::string> > rpaths_per_file;
 void changeLibPathsOnFile(std::string file_to_fix)
 {
     std::cout << "\n* Fixing dependencies on " << file_to_fix.c_str() << std::endl;
-    
+
     const int dep_amount = deps.size();
     for(int n=0; n<dep_amount; n++)
     {
@@ -64,7 +64,7 @@ void collectRpaths(const std::string& filename)
         return;
     }
 
-    std::string cmd = "otool -l " + filename;
+    std::string cmd = otool + " -l " + filename;
     std::string output = system_get_output(cmd);
 
     std::vector<std::string> lc_lines;
@@ -149,7 +149,7 @@ void fixRpathsOnFile(const std::string& original_file, const std::string& file_t
 
     for (size_t i=0; i < rpaths_to_fix.size(); ++i)
     {
-        std::string command = std::string("install_name_tool -rpath ") +
+        std::string command = install_name_tool + std::string(" -rpath ") +
                 rpaths_to_fix[i] + " " + Settings::inside_lib_path() + " " + file_to_fix;
         if ( systemp(command) != 0)
         {
@@ -162,16 +162,16 @@ void fixRpathsOnFile(const std::string& original_file, const std::string& file_t
 void addDependency(std::string path)
 {
     Dependency dep(path);
-    
+
     // we need to check if this library was already added to avoid duplicates
     const int dep_amount = deps.size();
     for(int n=0; n<dep_amount; n++)
     {
         if(dep.mergeIfSameAs(deps[n])) return;
     }
-    
+
     if(!Settings::isPrefixBundled(dep.getPrefix())) return;
-    
+
     deps.push_back(dep);
 }
 
@@ -181,7 +181,7 @@ void addDependency(std::string path)
 void collectDependencies(std::string filename, std::vector<std::string>& lines)
 {
     // execute "otool -L" on the given file and collect the command's output
-    std::string cmd = "otool -L " + filename;
+    std::string cmd = otool + " -L " + filename;
     std::string output = system_get_output(cmd);
 
     if(output.find("can't open file")!=std::string::npos or output.find("No such file")!=std::string::npos or output.size()<1)
@@ -189,7 +189,7 @@ void collectDependencies(std::string filename, std::vector<std::string>& lines)
         std::cerr << "Cannot find file " << filename << " to read its dependencies" << std::endl;
         exit(1);
     }
-    
+
     // split output
     tokenize(output, "\n", &lines);
 }
@@ -199,9 +199,9 @@ void collectDependencies(std::string filename)
 {
     std::vector<std::string> lines;
     collectDependencies(filename, lines);
-       
+
     std::cout << "."; fflush(stdout);
-    
+
     const int line_amount = lines.size();
     for(int n=0; n<line_amount; n++)
     {
@@ -223,7 +223,7 @@ void collectSubDependencies()
 {
     // print status to user
     int dep_amount = deps.size();
-    
+
     // recursively collect each dependencie's dependencies
     while(true)
     {
@@ -239,13 +239,13 @@ void collectSubDependencies()
             }
             collectRpathsForFilename(original_path);
             collectDependencies(original_path, lines);
-            
+
             const int line_amount = lines.size();
             for(int n=0; n<line_amount; n++)
             {
                 if(lines[n][0] != '\t') continue; // only lines beginning with a tab interest us
                 if( lines[n].find(".framework") != std::string::npos ) continue; //Ignore frameworks, we can not handle them
-                
+
                 // trim useless info, keep only library name
                 std::string dep_path = lines[n].substr(1, lines[n].rfind(" (") - 1);
                 if (isRpath(dep_path))
@@ -256,7 +256,7 @@ void collectSubDependencies()
                 addDependency(dep_path);
             }//next
         }//next
-        
+
         if(deps.size() == dep_amount) break; // no more dependencies were added on this iteration, stop searching
     }
 }
@@ -265,10 +265,10 @@ void createDestDir()
 {
     std::string dest_folder = Settings::destFolder();
     std::cout << "* Checking output directory " << dest_folder.c_str() << std::endl;
-    
+
     // ----------- check dest folder stuff ----------
     bool dest_exists = fileExists(dest_folder);
-    
+
     if(dest_exists and Settings::canOverwriteDir())
     {
         std::cout << "* Erasing old output directory " << dest_folder.c_str() << std::endl;
@@ -280,10 +280,10 @@ void createDestDir()
         }
         dest_exists = false;
     }
-    
+
     if(!dest_exists)
     {
-        
+
         if(Settings::canCreateDir())
         {
             std::cout << "* Creating output directory " << dest_folder.c_str() << std::endl;
@@ -300,7 +300,7 @@ void createDestDir()
             exit(1);
         }
     }
-    
+
 }
 
 void doneWithDeps_go()
@@ -313,12 +313,12 @@ void doneWithDeps_go()
         deps[n].print();
     }
     std::cout << std::endl;
-    
+
     // copy files if requested by user
     if(Settings::bundleLibs())
     {
         createDestDir();
-        
+
         for(int n=0; n<dep_amount; n++)
         {
             deps[n].copyYourself();
@@ -326,7 +326,7 @@ void doneWithDeps_go()
             fixRpathsOnFile(deps[n].getOriginalPath(), deps[n].getInstallPath());
         }
     }
-    
+
     const int fileToFixAmount = Settings::fileToFixAmount();
     for(int n=0; n<fileToFixAmount; n++)
     {
diff --git a/src/DylibBundler.h b/src/DylibBundler.h
index edf557b..d779f90 100644
--- a/src/DylibBundler.h
+++ b/src/DylibBundler.h
@@ -27,6 +27,8 @@ THE SOFTWARE.
 
 #include <string>
 
+#include "Constants.h"
+
 void collectDependencies(std::string filename);
 void collectSubDependencies();
 void doneWithDeps_go();
-- 
2.19.2

